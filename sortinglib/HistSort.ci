module HistSort{
  include "defs.h";
  initnode void register_sum_uint64_t(void);
  initnode void register_minmax_uint64_t(void);

  //readonly CkNodeGroupID nodeMgrID;
  

  template <class key, class value> chare Main {
    entry Main(int num_buckets_, int probe_max, int num_partitions_);
    entry void Exit();
    entry void DataReady();
    entry void init_isum(CkReductionMsg*);
    entry void intermediate_isum(CkReductionMsg*);
    entry void final_isum(CkReductionMsg*);
    entry void init_dsum(CkReductionMsg*);
    entry void final_dsum(CkReductionMsg*);
  };

  template <class key>
    message probeMessage {
      key probe[];
      key newachv_key[];
      int newachv_id[];
      uint64_t newachv_count[];
    };

  template <class key>
    message sampleMessage {
      key lb[];
      key ub[];
      key newachv_key[];
      int newachv_id[];
      uint64_t newachv_count[];
    };


  template <class key, class value>
    message data_msg {
      kv_pair<key, value> data[];
    };

  template <class key>
    message array_msg {
      key data[];
    };


 
  template <class key, class value> chare Sorter {
    entry Sorter();
    entry Sorter(const CkArrayID &bucketArr, int num_chares, key min, key max,  
                 tuning_params par, CProxy_Main<key, value> mainproxy, CkNodeGroupID _nodeMgrID);
    entry void finishBarrier(CkReductionMsg *msg);
    //entry void Begin();
    entry [expedited] void Histogram(CkReductionMsg *msg);
    //entry [expedited] void globalMinMax(CkReductionMsg *msg);
    entry void Done(CkReductionMsg *msg);
    entry void SanityCheck(CkReductionMsg *msg);
    entry void recvSample(array_msg<key> *am);
  };


  class sampleInfo;  
  class sendInfo;

  template <class key, class value> array [1D] Bucket {
    entry Bucket(tuning_params par, key _min, key _max, int nBuckets_, CkNodeGroupID _nodeMgrID);	  
    //entry void SetCallback(const CkCallback &cb);
    entry void startBarrier(CProxy_Sorter<key, value> _sorter_proxy, CProxy_Main<key, value> _main_proxy);
    entry void SetData();
    entry void genSample(sampleInfo sI);
    entry void firstProbe(key firstkey, key lastkey, key stepSize, int probeSize);
    entry [expedited] void firstLocalProbe(int lastProbeSize);
    entry [expedited] void histCountProbes(probeMessage<key> *pm);
    entry [expedited] void genNextSamples(sampleMessage<key> *sm);
    entry void sortAll();
    entry void stepSort();
    entry void Load(data_msg<key, value>* msg);
    entry void recvFinalKeys(int srcnode, sendInfo s);
    entry void MergingWork();
    entry void partialSendOne();
    entry void finalProbes(array_msg<key>* finalprb);
    entry void finish();
    //entry void Load();

  };


  class wrap_ptr;

  template <class key, class value> nodegroup NodeManager{
      entry NodeManager(key _minkey, key _maxkey);
      entry [exclusive] void registerLocalChare(
                  int nElem,
                  int pe,
                  CProxy_Bucket<key, value> _bucket_arr,
                  CProxy_Sorter<key, value> _sorter
                  );
      entry [exclusive, expedited] void collectSamples(sampleInfo sI);
      entry [exclusive] void assembleSamples(std::vector<key> proc_sample);
      entry [exclusive] void loadkeys(int dest, sendInfo inf);
      entry void sendOne(int dest);
      entry [exclusive] void releaseBufMsgs();
      entry [exclusive] void recvOne(data_msg<key, value> *dm);
      entry void handleOne(wrap_ptr msg, int sampleInd, int numsamples);
      entry [exclusive] void finishOne();
      entry void localhist(data_msg<key, value> *dm);
      entry [exclusive] void depositHist();
      entry [expedited] void sendToBuckets(data_msg<key, value>* dm);
  };
};

