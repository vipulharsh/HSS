module HistSort{
  include "defs.h";
  initnode void register_sum_uint64_t(void);
  initnode void register_minmax_uint64_t(void);
  

  template <class key, class value> chare Main {
    entry Main(int _num_buckets, int probe_max);
    entry void Exit();
    entry void DataReady();
    entry void init_isum(CkReductionMsg*);
    entry void final_isum(CkReductionMsg*);
    entry void init_dsum(CkReductionMsg*);
    entry void final_dsum(CkReductionMsg*);
  };

  template <class key>
    message probeMessage {
      key probe[];
      key newachv_key[];
      int newachv_id[];
    };

  template <class key, class value> chare Sorter {
    entry Sorter();
    entry Sorter(const CkArrayID &bucketArr, int num_chares, key min, key max, tuning_params par, CProxy_Main<key, value> mainproxy);
    entry void Begin();
    //!meaning of [expedited]
    entry [expedited] void Histogram(CkReductionMsg *msg);
    entry [expedited] void globalMinMax(CkReductionMsg *msg);
    entry void Done(CkReductionMsg *msg);
    entry void SanityCheck(CkReductionMsg *msg);
  };

  template <class key, class value> array [1D] Bucket {
    entry Bucket(tuning_params par, key _min, key _max, int nBuckets_);	  
    //entry void SetCallback(const CkCallback &cb);
    entry void SetData(CProxy_Sorter<key, value> _sorter_proxy);
    entry void firstProbe(key firstkey, key lastkey, int probesize);
    entry void firstLocalProbe(int lastProbeSize);
    entry void histCountProbes(probeMessage<key> *pm);
  	entry void checkMemoryCorruption();
    //!expedited? entry [expedited] void CountProbe(next_probe<key> *pb);
    //entry void Load(data_msg<key, value>* msg);
    //entry void Load();
  };
};

